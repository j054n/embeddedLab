`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    18:06:34 03/13/2014 
// Design Name: 
// Module Name:    addTwoNumbers 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module addTwoNumbers(
    input [15:0] NumberA,
    input [15:0] NumberB,
    output [15:0] Result
    );


endmodule
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    23:19:21 03/12/2014 
// Design Name: 
// Module Name:    asciiTo4BitBinary 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module asciiTo4BitBinary(
    input [7:0] input8BitAscii,
    output [3:0] output4BitBinary
    );


endmodule
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    23:22:24 03/12/2014 
// Design Name: 
// Module Name:    binary16BitTo4DigitHex 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module binary16BitTo4DigitHex(
    input [15:0] inputBinary16Bit,
    output hexDigit0,
    output hexDigit1,
    output hexDigit2,
    output hexDigit3
    );


endmodule
// Nexys3 and Atlys Spartan-6 FPGA Board
// Crystal Clock Oscillator  clkosc.v
// c 2012 Embedded Design using Programmable Gate Arrays
//        Second Edition   Dennis Silage

module clock(input CLK, input [31:0] clkscale, output reg sclclk);
									// CLK crystal clock oscillator 100 MHz
reg [31:0] clkq = 0;			// clock register, initial value of 0
	
always@(posedge CLK)
	begin
		clkq=clkq+1;			// increment clock register
			if (clkq>=clkscale)  	// clock scaling
				begin
					sclclk=~sclclk;	// output clock
					clkq=0;		// reset clock register
				end
	 end

endmodule
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    23:24:17 03/12/2014 
// Design Name: 
// Module Name:    lab4Control 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module lab4Control(
    input CLK,
    input dataAvailable,
    output loadFirstSign,
    output loadFirstDigit,
    output loadSecondDigit,
    output loadSecondSign,
    output addNumbers,
    output displayAnswer,
	 output dataReady
	 
    );


endmodule
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    23:28:04 03/12/2014 
// Design Name: 
// Module Name:    lab4DataPath 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module lab4DataPath(
    input [7:0] dataIn,
    output reg [7:0] dataOut,
    input loadFirstSign,
    input loadFirstDigit,
    input loadSecondDigit,
    input loadSecondSign,
    input addNumbers,
    input displayAnswer,
    input CLK
    );
	 
	 reg [3:0] temp4;
	 reg [15:0] numberA;
	 reg [15:0] numberB;
	 reg [15:0] answer;
	 reg [7:0] hex1, hex2, hex3, hex4;
	 
	 asciiTo4BitBinary  U1(.input8BitBinary(dataIn),
											.output4BitBinary(temp4)
											);
											
	 binary16BitTo4DigitHex  U2(.inputBinary16Bit(answer),
													.hexDigit0(hex1),
													.hexDigit1(hex2),
													.hexDigit3(hex3),
													.hexDigit3(hex4)
													);
	 
	 
	 addTwoNumbers U3(.NumberA(numberA),
									.NumberB(numberB),
									.Result(answer)
									);
	 

	//dataOut = hex1;

endmodule
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    23:14:42 03/12/2014 
// Design Name: 
// Module Name:    lab4_top_module 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module lab4_top_module(
    input CLK,
    input [0:0] RXD,
    output [0:0] TXD
    );

	//Declare wires.
	wire w1;
	wire w2;
	wire w3;
	wire w4;
	wire w5;
	wire w6;
	wire w7;
	wire w8;
	wire w9;
	wire [7:0] w10;
	wire [7:0] w11;
	wire w12;
	
	reg dataReady;
	
	//set initial values for transmit and receive initalization.
	parameter rdrstval = 0;
	parameter wrnval = 0;
	
	//Instantiate modules
	lab4Control M1 (.CLK(CLK),
							.dataAvailable(w9),
							.loadFirstSign(w1),
							.loadFirstDigit(w2),
							.loadSecondDigit(w3),
							.loadSecondSign(w4),
							.addNumbers(w5),
							.displayAnswer(w6),
							.dataReady(dataReady)
							);
							
	lab4DataPath M2 (.CLK(CLK),
							.dataIn(w7),
							.dataOut(w8),
							.dataAvailable(w9),
							.loadFirstSign(w1),
							.loadFirstDigit(w2),
							.loadSecondDigit(w3),
							.loadSecondSign(w4),
							.addNumbers(w5),
							.displayAnswer(w6),
							.dataReady(w7)
							);

	//Instantiate Clocks
	clock C0 (.CLK(CLK), .clkscale(326), .sclclk(clk16x));       // 9600 b/sec
	clock C1 (.CLK(CLK), .clkscale(5000), .sclclk(genclk));      // 10 kHz
							
	//Instantiate modules to handle transmit/receive.
	
	txmit M4(	.tdin(w11),
					.tbuf(TXD),
					.clk16x(clk16x),
					.wrn(wrnval),
					.txd(1)
					);
			
	

	rcvr M5( .rxd(RXD),
				.clk16x(clk16x),
				.rdrst(1),
				.rbr(w11),
				.rdrdy(w9),
				);


    endmodule
// UART Receiver rcvr.v
// c 2000 Xilinx, Inc. XAPP341
// c 2012 Embedded Design using Programmable Gate Arrays  Dennis Silage

module rcvr (output reg [7:0] rbr, output reg rdrdy, input rxd,
				 input clk16x, rdrst);
					
reg rxd1, rxd2, clk1x_en;
reg [3:0] clkdiv=0;
reg [7:0] rsr=0;			// receive shift register
reg [3:0] no_bits_rcvd;

assign clk1x=clkdiv[3];	// generate 1x clock

always @(posedge clk16x or posedge rdrst)		
	begin	
		if (rdrst==1)
			begin
				rxd1=1;		
				clk1x_en=0;		// clk1x enable
				clkdiv=0;
			end
		else 
			begin
				rxd2=rxd1;		// async edge detection for start bit
				rxd1=rxd;
				if (rxd1==0 && rxd2==1)
					clk1x_en=1;
				if (no_bits_rcvd==9) // start bit + 8 data bits
					begin
						clk1x_en=0;
						clkdiv=0;
					end
				if (clk1x_en==1)			// clk16x divider for clk1x		
					clkdiv=clkdiv+1;
			end
	end

always @(posedge clk1x or posedge rdrst)
	begin
		if (rdrst==1)	// reset
			begin
				rsr=0;
				rbr=0;
				rdrdy=0;		
			end
		else 
			begin
				if (no_bits_rcvd>=1 && no_bits_rcvd<=7)
					begin
						rsr[7]=rxd;
						rsr[6:0]=rsr[7:1];
					end
				else if (no_bits_rcvd==8)
					begin
						rsr[7]=rxd;
						rbr=rsr;
						rdrdy=1;		// receive data ready
					end
			end
	end
	
always @(negedge clk1x or posedge rdrst or negedge clk1x_en)
	begin
		if (rdrst==1 || clk1x_en==0)
			no_bits_rcvd=0;
		else
			no_bits_rcvd=no_bits_rcvd+1;
	end
	
endmodule
// UART Transmitter txmit.v
// c 2000 Xilinx, Inc. XAPP341
// c 2012 Embedded Design using Programmable Gate Arrays  Dennis Silage

module txmit (input [7:0] tdin, output reg tbuf, input clk16x, wrn,
				  output reg txd=1);

reg clk1x_en=0;
reg parity;
reg wrn1=1;
reg wrn2=1;
reg [7:0] tsr=0;
reg [7:0] tbr=0;
reg [3:0] clkdiv=0;
reg [3:0] no_bits_sent=0;

assign clk1x=clkdiv[3];		// generate 1x clock

always @(posedge clk16x) 
	begin
		wrn2=wrn1;		// async detection for write
		wrn1=wrn;
		if (wrn1==0 && wrn2==1) 
			begin
				clk1x_en=1;
				tbuf=1;	// transmit buffer not empty
			end
		if (no_bits_sent==2)
			tbuf=1;
		if (no_bits_sent==13)
			begin
				clk1x_en=0;
				tbuf=0;	// transmit buffer empty
			end
		if (clk1x_en)
			clkdiv=clkdiv+1;
	end

always @(posedge wrn)	// write transmit data
	tbr=tdin;

always @(negedge clk1x)	
	begin
		if (no_bits_sent==1)
			tsr=tbr;
		if (no_bits_sent==2)
			txd=0;
		if (no_bits_sent>=3 && no_bits_sent<=10)
			begin
				txd=tsr[0];
				tsr[6:0]=tsr[7:1];
				tsr[7]=0;
				parity=parity^tsr[0];	
			end
		if (no_bits_sent==11)
			txd=parity;
		if (no_bits_sent==12)
			txd=1;
		
	end
	
always @(posedge clk1x or negedge clk1x_en)
	begin
		if (clk1x_en==0)
			no_bits_sent=0;
		else
			no_bits_sent=no_bits_sent+1;
	end
	
endmodule
